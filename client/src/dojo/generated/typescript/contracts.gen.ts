// Generated by dojo-bindgen on Sat, 6 Apr 2024 04:41:16 +0000. Do not modify this file manually.
// @ts-nocheck

import { Account } from 'starknet';
import { DojoProvider } from '@dojoengine/core';
import * as models from './models.gen';

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
  // System definitions for `nogame::systems::defence::contract::defenceactions` contract
  function defenceactions() {
    const contract_name = 'defenceactions';

    // Call the `start_build` system with the specified Account and calldata
    const startBuild = async (props: {
      account: Account;
      component: models.DefenceBuildType;
      quantity: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'start_build',
          [props.component, props.quantity]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `complete_build` system with the specified Account and calldata
    const completeBuild = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'complete_build',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `dojo_resource` system with the specified Account and calldata
    const dojoResource = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dojo_resource',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    return {
      startBuild,
      completeBuild,
      dojoResource,
    };
  }

  // System definitions for `nogame::systems::dockyard::contract::dockyardactions` contract
  function dockyardactions() {
    const contract_name = 'dockyardactions';

    // Call the `start_build` system with the specified Account and calldata
    const startBuild = async (props: {
      account: Account;
      component: models.ShipBuildType;
      quantity: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'start_build',
          [props.component, props.quantity]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `complete_build` system with the specified Account and calldata
    const completeBuild = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'complete_build',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `dojo_resource` system with the specified Account and calldata
    const dojoResource = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dojo_resource',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    return {
      startBuild,
      completeBuild,
      dojoResource,
    };
  }

  // System definitions for `nogame::systems::fleet::contract::fleetactions` contract
  function fleetactions() {
    const contract_name = 'fleetactions';

    // Call the `dojo_resource` system with the specified Account and calldata
    const dojoResource = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dojo_resource',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `send_fleet` system with the specified Account and calldata
    const sendFleet = async (props: {
      account: Account;
      fleet: models.Fleet;
      destination: models.Position;
      cargo: models.Resources;
      mission_type: Number;
      speed_modifier: Number;
      colony_id: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'send_fleet',
          [
            props.fleet.carrier,
            props.fleet.scraper,
            props.fleet.sparrow,
            props.fleet.frigate,
            props.fleet.armade,
            props.destination.system,
            props.destination.orbit,
            props.cargo.steel,
            props.cargo.quartz,
            props.cargo.tritium,
            props.mission_type,
            props.speed_modifier,
            props.colony_id,
          ]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `attack_planet` system with the specified Account and calldata
    const attackPlanet = async (props: {
      account: Account;
      mission_id: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'attack_planet',
          [props.mission_id]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `recall_fleet` system with the specified Account and calldata
    const recallFleet = async (props: {
      account: Account;
      mission_id: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'recall_fleet',
          [props.mission_id]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `dock_fleet` system with the specified Account and calldata
    const dockFleet = async (props: {
      account: Account;
      mission_id: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dock_fleet',
          [props.mission_id]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `collect_debris` system with the specified Account and calldata
    const collectDebris = async (props: {
      account: Account;
      mission_id: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'collect_debris',
          [props.mission_id]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `simulate_attack` system with the specified Account and calldata
    const simulateAttack = async (props: {
      account: Account;
      attacker_fleet: models.Fleet;
      defender_fleet: models.Fleet;
      defences: models.Defences;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'simulate_attack',
          [
            props.attacker_fleet.carrier,
            props.attacker_fleet.scraper,
            props.attacker_fleet.sparrow,
            props.attacker_fleet.frigate,
            props.attacker_fleet.armade,
            props.defender_fleet.carrier,
            props.defender_fleet.scraper,
            props.defender_fleet.sparrow,
            props.defender_fleet.frigate,
            props.defender_fleet.armade,
            props.defences,
          ]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    return {
      dojoResource,
      sendFleet,
      attackPlanet,
      recallFleet,
      dockFleet,
      collectDebris,
      simulateAttack,
    };
  }

  // System definitions for `nogame::systems::planet::contract::planetactions` contract
  function planetactions() {
    const contract_name = 'planetactions';

    // Call the `dojo_resource` system with the specified Account and calldata
    const dojoResource = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dojo_resource',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `generate_planet` system with the specified Account and calldata
    const generatePlanet = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'generate_planet',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `get_uncollected_resources` system with the specified Account and calldata
    const getUncollectedResources = async (props: { planet_id: Number }) => {
      try {
        return (await provider.callContract(
          'planetactions',
          'get_uncollected_resources',
          [props.planet_id]
        )) as models.Resources;
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `get_last_collection_time` system with the specified Account and calldata
    const getLastCollectionTime = async (props: {
      account: Account;
      planet_id: Number;
    }) => {
      try {
        return await provider.callContract(
          props.account,
          contract_name,
          'get_last_collection_time',
          [props.planet_id]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    return {
      dojoResource,
      generatePlanet,
      getUncollectedResources,
      getLastCollectionTime,
    };
  }

  // System definitions for `nogame::systems::colony::contract::colonyactions` contract
  function colonyactions() {
    const contract_name = 'colonyactions';

    // Call the `generate_colony` system with the specified Account and calldata
    const generateColony = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'generate_colony',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `start_compound_upgrade` system with the specified Account and calldata
    const startCompoundUpgrade = async (props: {
      account: Account;
      colony_id: Number;
      name: models.CompoundUpgradeType;
      quantity: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'start_compound_upgrade',
          [props.colony_id, props.name, props.quantity]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `complete_compound_upgrade` system with the specified Account and calldata
    const completeCompoundUpgrade = async (props: {
      account: Account;
      colony_id: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'complete_compound_upgrade',
          [props.colony_id]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `start_ship_build` system with the specified Account and calldata
    const startShipBuild = async (props: {
      account: Account;
      colony_id: Number;
      name: models.ShipBuildType;
      quantity: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'start_ship_build',
          [props.colony_id, props.name, props.quantity]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `complete_ship_build` system with the specified Account and calldata
    const completeShipBuild = async (props: {
      account: Account;
      colony_id: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'complete_ship_build',
          [props.colony_id]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `start_defence_build` system with the specified Account and calldata
    const startDefenceBuild = async (props: {
      account: Account;
      colony_id: Number;
      name: models.DefenceBuildType;
      quantity: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'start_defence_build',
          [props.colony_id, props.name, props.quantity]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `complete_defence_build` system with the specified Account and calldata
    const completeDefenceBuild = async (props: {
      account: Account;
      colony_id: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'complete_defence_build',
          [props.colony_id]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `get_uncollected_resources` system with the specified Account and calldata
    const getUncollectedResources = async (props: {
      planet_id: Number;
      colony_id: Number;
    }) => {
      try {
        return (await provider.callContract(
          'colonyactions',
          'get_uncollected_resources',
          [props.planet_id, props.colony_id]
        )) as models.Resources;
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `dojo_resource` system with the specified Account and calldata
    const dojoResource = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dojo_resource',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    return {
      generateColony,
      startCompoundUpgrade,
      completeCompoundUpgrade,
      startShipBuild,
      completeShipBuild,
      startDefenceBuild,
      completeDefenceBuild,
      getUncollectedResources,
      dojoResource,
    };
  }

  // System definitions for `nogame::systems::compound::contract::compoundactions` contract
  function compoundactions() {
    const contract_name = 'compoundactions';

    // Call the `dojo_resource` system with the specified Account and calldata
    const dojoResource = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dojo_resource',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `start_upgrade` system with the specified Account and calldata
    const startUpgrade = async (props: {
      account: Account;
      component: models.CompoundUpgradeType;
      quantity: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'start_upgrade',
          [props.component, props.quantity]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `complete_upgrade` system with the specified Account and calldata
    const completeUpgrade = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'complete_upgrade',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    return {
      dojoResource,
      startUpgrade,
      completeUpgrade,
    };
  }

  // System definitions for `nogame::systems::game::contract::gameactions` contract
  function gameactions() {
    const contract_name = 'gameactions';

    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account; speed: Number }) => {
      try {
        return await provider.execute(props.account, contract_name, 'spawn', [
          props.speed,
        ]);
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `dojo_resource` system with the specified Account and calldata
    const dojoResource = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dojo_resource',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    return {
      spawn,
      dojoResource,
    };
  }

  // System definitions for `nogame::systems::tech::contract::techactions` contract
  function techactions() {
    const contract_name = 'techactions';

    // Call the `start_upgrade` system with the specified Account and calldata
    const startUpgrade = async (props: {
      account: Account;
      component: models.TechUpgradeType;
      quantity: Number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'start_upgrade',
          [props.component, props.quantity]
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `complete_upgrade` system with the specified Account and calldata
    const completeUpgrade = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'complete_upgrade',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    // Call the `dojo_resource` system with the specified Account and calldata
    const dojoResource = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          contract_name,
          'dojo_resource',
          []
        );
      } catch (error) {
        console.error('Error executing spawn:', error);
        throw error;
      }
    };

    return {
      startUpgrade,
      completeUpgrade,
      dojoResource,
    };
  }

  return {
    defenceactions: defenceactions(),
    dockyardactions: dockyardactions(),
    fleetactions: fleetactions(),
    planetactions: planetactions(),
    colonyactions: colonyactions(),
    compoundactions: compoundactions(),
    gameactions: gameactions(),
    techactions: techactions(),
  };
}
